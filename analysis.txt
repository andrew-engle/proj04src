
1). makeEmpty(BinaryNode* &t): This function deletes all the nodes in the subtree pointed to by t. To do this, the function recursively traverses the subtree and deletes each node. The time complexity of this function is O(n), where n is the number of nodes in the subtree. This is because the function visits each node once and performs a constant amount of work (i.e., deleting the node) for each node.

2). depth(BinaryNode* &t): This function returns the depth of the subtree pointed to by t. The depth of a node is the number of edges from the node to the root of the tree. To compute the depth, the function recursively traverses the subtree and adds 1 to the depth for each level of the tree. The time complexity of this function is O(n), where n is the number of nodes in the subtree. This is because the function visits each node once and performs a constant amount of work (i.e., adding 1 to the depth) for each node.

3.) breadth(BinaryNode* &t): This function returns the breadth of the subtree pointed to by t. The breadth of a tree is the maximum number of nodes at any level of the tree. To compute the breadth, the function performs a level-order traversal of the tree using a queue data structure. The function visits each node once and performs a constant amount of work (i.e., adding the node's children to the queue) for each node. The time complexity of this function is O(n), where n is the number of nodes in the subtree. This is because the function visits each node once and performs a constant amount of work for each node. However, the space complexity of this function is O(w), where w is the maximum width of the tree (i.e., the maximum number of nodes at any level of the tree). This is because the queue used to perform the level-order traversal can store up to w nodes at a time.